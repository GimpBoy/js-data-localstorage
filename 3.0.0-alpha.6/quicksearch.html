<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" js-data-localstorage Modules js-data-localstorage Classes LocalStorageAdapter Source: index.js /* global: localStorage */ const JSData = require('js-data') const Adapter = require('js-data-adapter') const guid = require('mout/random/guid') const { Query, utils } = JSData const { addHiddenPropsToTarget, deepMixIn, extend, fillIn, forOwn, fromJson, get, isArray, isUndefined, reject, set, toJson } = utils function isValidString (value) { return (value != null &amp;&amp; value !== '') } function join (items, separator) { separator || (separator = '') return items.filter(isValidString).join(separator) } function makePath (...args) { let result = join(args, '/') return result.replace(/([^:\\/]|^)\\/{2,}/g, '$1/') } let queue = [] let taskInProcess = false function enqueue (task) { queue.push(task) } function dequeue () { if (queue.length &amp;&amp; !taskInProcess) { taskInProcess = true queue[0]() } } function queueTask (task) { if (!queue.length) { enqueue(task) dequeue() } else { enqueue(task) } } function createTask (fn) { return new Promise(fn).then(function (result) { taskInProcess = false queue.shift() setTimeout(dequeue, 0) return result }, function (err) { taskInProcess = false queue.shift() setTimeout(dequeue, 0) return reject(err) }) } const __super__ = Adapter.prototype const DEFAULTS = { /** * TODO * * @name LocalStorageAdapter#basePath * @type {string} */ basePath: '', /** * TODO * * @name LocalStorageAdapter#debug * @type {boolean} * @default false */ debug: false, /** * TODO * * @name LocalStorageAdapter#storage * @type {Object} * @default localStorage */ storage: localStorage } /** * LocalStorageAdapter class. * * @example * import {DataStore} from 'js-data' * import LocalStorageAdapter from 'js-data-localstorage' * const store = new DataStore() * const adapter = new LocalStorageAdapter() * store.registerAdapter('ls', adapter, { 'default': true }) * * @class LocalStorageAdapter * @param {Object} [opts] Configuration opts. * @param {string} [opts.basePath=''] TODO * @param {boolean} [opts.debug=false] TODO * @param {Object} [opts.storeage=localStorage] TODO */ function LocalStorageAdapter (opts) { const self = this opts || (opts = {}) fillIn(opts, DEFAULTS) Adapter.call(self, opts) } // Setup prototype inheritance from Adapter LocalStorageAdapter.prototype = Object.create(Adapter.prototype, { constructor: { value: LocalStorageAdapter, enumerable: false, writable: true, configurable: true } }) Object.defineProperty(LocalStorageAdapter, '__super__', { configurable: true, value: Adapter }) /** * Alternative to ES6 class syntax for extending `LocalStorageAdapter`. * * @name LocalStorageAdapter.extend * @method * @param {Object} [instanceProps] Properties that will be added to the * prototype of the subclass. * @param {Object} [classProps] Properties that will be added as static * properties to the subclass itself. * @return {Object} Subclass of `LocalStorageAdapter`. */ LocalStorageAdapter.extend = extend addHiddenPropsToTarget(LocalStorageAdapter.prototype, { _createHelper (mapper, props, opts) { const self = this const _props = {} const relationFields = mapper.relationFields || [] forOwn(props, function (value, key) { if (relationFields.indexOf(key) === -1) { _props[key] = value } }) const id = get(_props, mapper.idAttribute) || guid() set(_props, mapper.idAttribute, id) const key = self.getIdPath(mapper, opts, id) // Create the record // TODO: Create related records when the &quot;with&quot; option is provided self.storage.setItem(key, toJson(_props)) self.ensureId(id, mapper, opts) return fromJson(self.storage.getItem(key)) }, /** * Create a new record. Internal method used by Adapter#create. * * @name LocalStorageAdapter#_create * @method * @private * @param {Object} mapper The mapper. * @param {Object} props The record to be created. * @param {Object} [opts] Configuration options. * @return {Promise} */ _create (mapper, props, opts) { const self = this return new Promise(function (resolve) { return resolve([self._createHelper(mapper, props, opts), {}]) }) }, /** * Create multiple records in a single batch. Internal method used by * Adapter#createMany. * * @name LocalStorageAdapter#_createMany * @method * @private * @param {Object} mapper The mapper. * @param {Object} props The records to be created. * @param {Object} [opts] Configuration options. * @return {Promise} */ _createMany (mapper, props, opts) { const self = this return new Promise(function (resolve) { props || (props = []) return resolve([props.map(function (_props) { return self._createHelper(mapper, _props, opts) }), {}]) }) }, /** * Destroy the record with the given primary key. Internal method used by * Adapter#destroy. * * @name LocalStorageAdapter#_destroy * @method * @private * @param {Object} mapper The mapper. * @param {(string|number)} id Primary key of the record to destroy. * @param {Object} [opts] Configuration options. * @return {Promise} */ _destroy (mapper, id, opts) { const self = this return new Promise(function (resolve) { self.storage.removeItem(self.getIdPath(mapper, opts, id)) self.removeId(id, mapper, opts) return resolve([undefined, {}]) }) }, /** * Destroy the records that match the selection query. Internal method used by * Adapter#destroyAll. * * @name LocalStorageAdapter#_destroyAll * @method * @private * @param {Object} mapper the mapper. * @param {Object} [query] Selection query. * @param {Object} [opts] Configuration options. * @return {Promise} */ _destroyAll (mapper, query, opts) { const self = this return self._findAll(mapper, query).then(function (results) { let [records] = results const idAttribute = mapper.idAttribute // Gather IDs of records to be destroyed const ids = records.map(function (record) { return get(record, idAttribute) }) // Destroy each record ids.forEach(function (id) { self.storage.removeItem(self.getIdPath(mapper, opts, id)) }) self.removeId(ids, mapper, opts) return [undefined, {}] }) }, /** * Retrieve the record with the given primary key. Internal method used by * Adapter#find. * * @name LocalStorageAdapter#_find * @method * @private * @param {Object} mapper The mapper. * @param {(string|number)} id Primary key of the record to retrieve. * @param {Object} [opts] Configuration options. * @return {Promise} */ _find (mapper, id, opts) { const self = this return new Promise(function (resolve) { const key = self.getIdPath(mapper, opts, id) const record = self.storage.getItem(key) return resolve([record ? fromJson(record) : undefined, {}]) }) }, /** * Retrieve the records that match the selection query. Internal method used * by Adapter#findAll. * * @name LocalStorageAdapter#_findAll * @method * @private * @param {Object} mapper The mapper. * @param {Object} query Selection query. * @param {Object} [opts] Configuration options. * @return {Promise} */ _findAll (mapper, query, opts) { const self = this query || (query = {}) return new Promise(function (resolve) { // Load all records into memory... let records = [] const ids = self.getIds(mapper, opts) forOwn(ids, function (value, id) { const json = self.storage.getItem(self.getIdPath(mapper, opts, id)) if (json) { records.push(fromJson(json)) } }) const _query = new Query({ index: { getAll () { return records } } }) return resolve([_query.filter(query).run(), {}]) }) }, /** * Apply the given update to the record with the specified primary key. * Internal method used by Adapter#update. * * @name LocalStorageAdapter#_update * @method * @private * @param {Object} mapper The mapper. * @param {(string|number)} id The primary key of the record to be updated. * @param {Object} props The update to apply to the record. * @param {Object} [opts] Configuration options. * @return {Promise} */ _update (mapper, id, props, opts) { const self = this props || (props = {}) return new Promise(function (resolve, reject) { const key = self.getIdPath(mapper, opts, id) let record = self.storage.getItem(key) if (!record) { return reject(new Error('Not Found')) } record = fromJson(record) deepMixIn(record, props) self.storage.setItem(key, toJson(record)) return resolve([record, {}]) }) }, /** * Apply the given update to all records that match the selection query. * Internal method used by Adapter#updateAll. * * @name LocalStorageAdapter#_updateAll * @method * @private * @param {Object} mapper The mapper. * @param {Object} props The update to apply to the selected records. * @param {Object} [query] Selection query. * @param {Object} [opts] Configuration options. * @return {Promise} */ _updateAll (mapper, props, query, opts) { const self = this const idAttribute = mapper.idAttribute return self._findAll(mapper, query, opts).then(function (results) { let [records] = results records.forEach(function (record) { record || (record = {}) const id = get(record, idAttribute) const key = self.getIdPath(mapper, opts, id) deepMixIn(record, props) self.storage.setItem(key, toJson(record)) }) return [records, {}] }) }, /** * Update the given records in a single batch. Internal method used by * Adapter#updateMany. * * @name LocalStorageAdapter#updateMany * @method * @private * @param {Object} mapper The mapper. * @param {Object[]} records The records to update. * @param {Object} [opts] Configuration options. * @return {Promise} */ _updateMany (mapper, records, opts) { const self = this records || (records = []) return new Promise(function (resolve) { const updatedRecords = [] const idAttribute = mapper.idAttribute records.forEach(function (record) { if (!record) { return } const id = get(record, idAttribute) if (isUndefined(id)) { return } const key = self.getIdPath(mapper, opts, id) let json = self.storage.getItem(key) if (!json) { return } const existingRecord = fromJson(json) deepMixIn(existingRecord, record) self.storage.setItem(key, toJson(existingRecord)) updatedRecords.push(existingRecord) }) return resolve([records, {}]) }) }, create (mapper, props, opts) { const self = this return createTask(function (success, failure) { queueTask(function () { __super__.create.call(self, mapper, props, opts).then(success, failure) }) }) }, createMany (mapper, props, opts) { const self = this return createTask(function (success, failure) { queueTask(function () { __super__.createMany.call(self, mapper, props, opts).then(success, failure) }) }) }, destroy (mapper, id, opts) { const self = this return createTask(function (success, failure) { queueTask(function () { __super__.destroy.call(self, mapper, id, opts).then(success, failure) }) }) }, destroyAll (mapper, query, opts) { const self = this return createTask(function (success, failure) { queueTask(function () { __super__.destroyAll.call(self, mapper, query, opts).then(success, failure) }) }) }, /** * TODO * * @name LocalStorageAdapter#ensureId * @method */ ensureId (id, mapper, opts) { const ids = this.getIds(mapper, opts) if (isArray(id)) { if (!id.length) { return } id.forEach(function (_id) { ids[_id] = 1 }) } else { ids[id] = 1 } this.saveKeys(ids, mapper, opts) }, /** * TODO * * @name LocalStorageAdapter#getPath * @method */ getPath (mapper, opts) { opts = opts || {} return makePath(opts.basePath === undefined ? (mapper.basePath === undefined ? this.basePath : mapper.basePath) : opts.basePath, mapper.name) }, /** * TODO * * @name LocalStorageAdapter#getIdPath * @method */ getIdPath (mapper, opts, id) { opts = opts || {} return makePath(opts.basePath || this.basePath || mapper.basePath, mapper.endpoint, id) }, /** * TODO * * @name LocalStorageAdapter#getIds * @method */ getIds (mapper, opts) { let ids const idsPath = this.getPath(mapper, opts) const idsJson = this.storage.getItem(idsPath) if (idsJson) { ids = fromJson(idsJson) } else { ids = {} } return ids }, /** * TODO * * @name LocalStorageAdapter#removeId * @method */ removeId (id, mapper, opts) { const ids = this.getIds(mapper, opts) if (isArray(id)) { if (!id.length) { return } id.forEach(function (_id) { delete ids[_id] }) } else { delete ids[id] } this.saveKeys(ids, mapper, opts) }, /** * TODO * * @name LocalStorageAdapter#saveKeys * @method */ saveKeys (ids, mapper, opts) { ids = ids || {} const idsPath = this.getPath(mapper, opts) if (Object.keys(ids).length) { this.storage.setItem(idsPath, toJson(ids)) } else { this.storage.removeItem(idsPath) } }, update (mapper, id, props, opts) { const self = this return createTask(function (success, failure) { queueTask(function () { __super__.update.call(self, mapper, id, props, opts).then(success, failure) }) }) }, updateAll (mapper, props, query, opts) { const self = this return createTask(function (success, failure) { queueTask(function () { __super__.updateAll.call(self, mapper, props, query, opts).then(success, failure) }) }) }, updateMany (mapper, records, opts) { const self = this return createTask(function (success, failure) { queueTask(function () { __super__.updateMany.call(self, mapper, records, opts).then(success, failure) }) }) } }) /** * Details of the current version of the `js-data-localstorage` module. * * @name LocalStorageAdapter.version * @type {Object} * @property {string} version.full The full semver value. * @property {number} version.major The major version number. * @property {number} version.minor The minor version number. * @property {number} version.patch The patch version number. * @property {(string|boolean)} version.alpha The alpha version value, * otherwise `false` if the current version is not alpha. * @property {(string|boolean)} version.beta The beta version value, * otherwise `false` if the current version is not beta. */ LocalStorageAdapter.version = { full: '&lt;%= pkg.version %&gt;', major: parseInt('&lt;%= major %&gt;', 10), minor: parseInt('&lt;%= minor %&gt;', 10), patch: parseInt('&lt;%= patch %&gt;', 10), alpha: '&lt;%= alpha %&gt;' !== 'false' ? '&lt;%= alpha %&gt;' : false, beta: '&lt;%= beta %&gt;' !== 'false' ? '&lt;%= beta %&gt;' : false } /** * Registered as `js-data-localstorage` in NPM and Bower. * * __Script tag__: * ```javascript * window.LocalStorageAdapter * ``` * __CommonJS__: * ```javascript * var LocalStorageAdapter = require('js-data-localstorage') * ``` * __ES6 Modules__: * ```javascript * import LocalStorageAdapter from 'js-data-localstorage' * ``` * __AMD__: * ```javascript * define('myApp', ['js-data-localstorage'], function (LocalStorageAdapter) { ... }) * ``` * * @module js-data-localstorage */ module.exports = LocalStorageAdapter × Search results Close Back to js-data.io "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" js-data-localstorage Modules js-data-localstorage Classes LocalStorageAdapter Modules Classes LocalStorageAdapter × Search results Close Back to js-data.io "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" js-data-localstorage Modules js-data-localstorage Classes LocalStorageAdapter Classes Classes LocalStorageAdapter × Search results Close Back to js-data.io "},"index.html":{"id":"index.html","title":"Index","body":" js-data-localstorage Modules js-data-localstorage Classes LocalStorageAdapter js-data-localstorage 3.0.0-alpha.6 js-data-localstorage localStorage adapter for js-data. Tested on IE9, Chrome 46, Firefox 41 &amp; Safari 7.1 using Table of contents Quick start Guides and Tutorials API Reference Demo Support Community Contributing License Quick Startnpm install --save js-data js-data-localstorage or bower install --save js-data js-data-localstorage. Load js-data-localstorage.js after js-data.js. var adapter = new LocalStorageAdapter(); var store = new JSData.DataStore(); store.registerAdapter('localstorage', adapter, { default: true }); // &quot;store&quot; will now use the localstorage adapterYou can also provide a custom storage medium (it just needs to implement the localStorage API): var memory = {}; // Turn js-data-localstorage into an in-memory adapter var memoryAdapter = new LocalStorageAdapter({ storage: { getItem: function (key) { return memory[key]; }, setItem: function (key, value) { return memory[key] = value; }, removeItem: function (key) { delete memory[key]; } } }); // Turn js-data-localstorage into a sessionStorage adapter var sessionAdapter = new LocalStorageAdapter({ storage: sessionStorage });Guides and TutorialsGet started at http://js-data.io API Reference DocsVisit http://api.js-data.io. Demohttps://js-data-localstorage.firebaseapp.com/ CommunityExplore the Community. SupportFind out how to Get Support. ContributingRead the Contributing Guide. LicenseThe MIT License (MIT) Copyright (c) 2014-2016 js-data-http project authors LICENSE AUTHORS CONTRIBUTORS × Search results Close Back to js-data.io "},"LocalStorageAdapter.html":{"id":"LocalStorageAdapter.html","title":"Class: LocalStorageAdapter","body":" js-data-localstorage Modules js-data-localstorage Classes LocalStorageAdapter Class: LocalStorageAdapter LocalStorageAdapter new LocalStorageAdapter(opts) LocalStorageAdapter class. Parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration opts. Properties Name Type Argument Default Description basePath string &lt;optional&gt; '' TODO debug boolean &lt;optional&gt; false TODO storeage Object &lt;optional&gt; localStorage TODO Source: index.js, line 104 Example import {DataStore} from 'js-data' import LocalStorageAdapter from 'js-data-localstorage' const store = new DataStore() const adapter = new LocalStorageAdapter() store.registerAdapter('ls', adapter, { 'default': true }) Members &lt;static&gt; version :Object Details of the current version of the js-data-localstorage module. Type: Object Properties: Name Type Description version.full string The full semver value. version.major number The major version number. version.minor number The minor version number. version.patch number The patch version number. version.alpha string | boolean The alpha version value, otherwise false if the current version is not alpha. version.beta string | boolean The beta version value, otherwise false if the current version is not beta. Source: index.js, line 584 basePath :string TODO Type: string Source: index.js, line 77 debug :boolean TODO Type: boolean Default Value: false Source: index.js, line 85 storage :Object TODO Type: Object Default Value: localStorage Source: index.js, line 94 Methods &lt;static&gt; extend(instanceProps, classProps) Alternative to ES6 class syntax for extending LocalStorageAdapter. Parameters: Name Type Argument Description instanceProps Object &lt;optional&gt; Properties that will be added to the prototype of the subclass. classProps Object &lt;optional&gt; Properties that will be added as static properties to the subclass itself. Source: index.js, line 142 Returns: Subclass of LocalStorageAdapter. Type Object ensureId() TODO Source: index.js, line 458 getIdPath() TODO Source: index.js, line 490 getIds() TODO Source: index.js, line 501 getPath() TODO Source: index.js, line 479 removeId() TODO Source: index.js, line 519 saveKeys() TODO Source: index.js, line 540 × Search results Close Back to js-data.io "},"module-js-data-localstorage.html":{"id":"module-js-data-localstorage.html","title":"Module: js-data-localstorage","body":" js-data-localstorage Modules js-data-localstorage Classes LocalStorageAdapter Module: js-data-localstorage Registered as js-data-localstorage in NPM and Bower. Script tag: window.LocalStorageAdapterCommonJS: var LocalStorageAdapter = require('js-data-localstorage')ES6 Modules: import LocalStorageAdapter from 'js-data-localstorage'AMD: define('myApp', ['js-data-localstorage'], function (LocalStorageAdapter) { ... }) Source: index.js, line 607 × Search results Close Back to js-data.io "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
