<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"-_Users_jdobry_projects_js-data-localstorage_src_index.js.html":{"id":"-_Users_jdobry_projects_js-data-localstorage_src_index.js.html","title":"Source: /Users/jdobry/projects/js-data-localstorage/src/index.js","body":" js-data-localstorage Modules js-data-localstorage Classes LocalStorageAdapter Source: /Users/jdobry/projects/js-data-localstorage/src/index.js /* global: localStorage */ const JSData = require('js-data') const guid = require('mout/random/guid') const { Query, utils } = JSData const { addHiddenPropsToTarget, deepMixIn, extend, fillIn, forEachRelation, forOwn, fromJson, get, isArray, isUndefined, resolve, reject, set, toJson } = utils function isValidString (value) { return (value != null &amp;&amp; value !== '') } function join (items, separator) { separator || (separator = '') return items.filter(isValidString).join(separator) } function makePath (...args) { let result = join(args, '/') return result.replace(/([^:\\/]|^)\\/{2,}/g, '$1/') } function unique (array) { const seen = {} const final = [] array.forEach(function (item) { if (item in seen) { return } final.push(item) seen[item] = 0 }) return final } let queue = [] let taskInProcess = false function enqueue (task) { queue.push(task) } function dequeue () { if (queue.length &amp;&amp; !taskInProcess) { taskInProcess = true queue[0]() } } function queueTask (task) { if (!queue.length) { enqueue(task) dequeue() } else { enqueue(task) } } function createTask (fn) { return new Promise(fn).then(function (result) { taskInProcess = false queue.shift() setTimeout(dequeue, 0) return result }, function (err) { taskInProcess = false queue.shift() setTimeout(dequeue, 0) return reject(err) }) } const noop = function (...args) { const self = this const opts = args[args.length - 1] self.dbg(opts.op, ...args) return resolve() } const noop2 = function (...args) { const self = this const opts = args[args.length - 2] self.dbg(opts.op, ...args) return resolve() } const DEFAULTS = { /** * TODO * * @name LocalStorageAdapter#basePath * @type {string} */ basePath: '', /** * TODO * * @name LocalStorageAdapter#debug * @type {boolean} * @default false */ debug: false, /** * TODO * * @name LocalStorageAdapter#storage * @type {Object} * @default localStorage */ storage: localStorage } /** * LocalStorageAdapter class. * * @example * import {DataStore} from 'js-data' * import LocalStorageAdapter from 'js-data-localstorage' * const store = new DataStore() * const adapter = new LocalStorageAdapter() * store.registerAdapter('ls', adapter, { 'default': true }) * * @class LocalStorageAdapter * @param {Object} [opts] Configuration opts. * @param {string} [opts.basePath=''] TODO * @param {boolean} [opts.debug=false] TODO * @param {Object} [opts.storeage=localStorage] TODO */ function LocalStorageAdapter (opts) { fillIn(this, opts || {}) fillIn(this, DEFAULTS) } /** * Alternative to ES6 class syntax for extending `LocalStorageAdapter`. * * @name LocalStorageAdapter.extend * @method * @param {Object} [instanceProps] Properties that will be added to the * prototype of the subclass. * @param {Object} [classProps] Properties that will be added as static * properties to the subclass itself. * @return {Object} Subclass of `LocalStorageAdapter`. */ LocalStorageAdapter.extend = extend addHiddenPropsToTarget(LocalStorageAdapter.prototype, { /** * @name LocalStorageAdapter#afterCreate * @method */ afterCreate: noop2, /** * @name LocalStorageAdapter#afterCreateMany * @method */ afterCreateMany: noop2, /** * @name LocalStorageAdapter#afterDEL * @method */ afterDEL: noop2, /** * @name LocalStorageAdapter#afterDestroy * @method */ afterDestroy: noop2, /** * @name LocalStorageAdapter#afterDestroyAll * @method */ afterDestroyAll: noop2, /** * @name LocalStorageAdapter#afterFind * @method */ afterFind: noop2, /** * @name LocalStorageAdapter#afterFindAll * @method */ afterFindAll: noop2, /** * @name LocalStorageAdapter#afterGET * @method */ afterGET: noop2, /** * @name LocalStorageAdapter#afterPUT * @method */ afterPUT: noop2, /** * @name LocalStorageAdapter#afterUpdate * @method */ afterUpdate: noop2, /** * @name LocalStorageAdapter#afterUpdateAll * @method */ afterUpdateAll: noop2, /** * @name LocalStorageAdapter#afterUpdateMany * @method */ afterUpdateMany: noop2, /** * @name LocalStorageAdapter#beforeCreate * @method */ beforeCreate: noop, /** * @name LocalStorageAdapter#beforeCreateMany * @method */ beforeCreateMany: noop, /** * @name LocalStorageAdapter#beforeDEL * @method */ beforeDEL: noop, /** * @name LocalStorageAdapter#beforeDestroy * @method */ beforeDestroy: noop, /** * @name LocalStorageAdapter#beforeDestroyAll * @method */ beforeDestroyAll: noop, /** * @name LocalStorageAdapter#beforeFind * @method */ beforeFind: noop, /** * @name LocalStorageAdapter#beforeFindAll * @method */ beforeFindAll: noop, /** * @name LocalStorageAdapter#beforeGET * @method */ beforeGET: noop, /** * @name LocalStorageAdapter#beforePUT * @method */ beforePUT: noop, /** * @name LocalStorageAdapter#beforeUpdate * @method */ beforeUpdate: noop, /** * @name LocalStorageAdapter#beforeUpdateAll * @method */ beforeUpdateAll: noop, /** * @name LocalStorageAdapter#beforeUpdateMany * @method */ beforeUpdateMany: noop, /** * Create a new record. * * @name LocalStorageAdapter#create * @method * @param {Object} mapper The mapper. * @param {Object} props The record to be created. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] TODO * @return {Promise} */ create (mapper, props, opts) { const self = this props || (props = {}) opts || (opts = {}) return createTask(function (success, failure) { queueTask(function () { let op // beforeCreate lifecycle hook op = opts.op = 'beforeCreate' return resolve(self[op](mapper, props, opts)).then(function (_props) { // Allow for re-assignment from lifecycle hook let record = isUndefined(_props) ? props : _props const id = get(record, mapper.idAttribute) || guid() set(record, mapper.idAttribute, id) const key = self.getIdPath(mapper, opts, id) // Create the record // TODO: Create related records when the &quot;with&quot; option is provided self.storage.setItem(key, toJson(record)) self.ensureId(id, mapper, opts) // afterCreate lifecycle hook op = opts.op = 'afterCreate' return self[op](mapper, props, opts, record).then(function (_record) { // Allow for re-assignment from lifecycle hook record = isUndefined(_record) ? record : _record return opts.raw ? { data: record, created: 1 } : record }) }).then(success, failure) }) }) }, /** * Create multiple records in a single batch. * * @name LocalStorageAdapter#createMany * @method * @param {Object} mapper The mapper. * @param {Array} props Array of records to be created. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] TODO * @return {Promise} */ createMany (mapper, props, opts) { const self = this props || (props = {}) opts || (opts = {}) return createTask(function (success, failure) { queueTask(function () { let op // beforeCreateMany lifecycle hook op = opts.op = 'beforeCreateMany' return resolve(self[op](mapper, props, opts)).then(function (_props) { // Allow for re-assignment from lifecycle hook let records = isUndefined(_props) ? props : _props const idAttribute = mapper.idAttribute // Create the record // TODO: Create related records when the &quot;with&quot; option is provided records.forEach(function (record) { const id = get(record, idAttribute) || guid() set(record, idAttribute, id) const key = self.getIdPath(mapper, opts, id) self.storage.setItem(key, toJson(record)) self.ensureId(id, mapper, opts) }) // afterCreateMany lifecycle hook op = opts.op = 'afterCreateMany' return self[op](mapper, props, opts, records).then(function (_records) { // Allow for re-assignment from lifecycle hook records = isUndefined(_records) ? records : _records return opts.raw ? { data: records, created: records.length } : records }) }).then(success, failure) }) }) }, /** * @name LocalStorageAdapter#dbg * @method */ dbg (...args) { this.log('debug', ...args) }, /** * Destroy the record with the given primary key. * * @name LocalStorageAdapter#destroy * @method * @param {Object} mapper The mapper. * @param {(string|number)} id Primary key of the record to destroy. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] TODO * @return {Promise} */ destroy (mapper, id, opts) { const self = this opts || (opts = {}) return createTask(function (success, failure) { queueTask(function () { let op // beforeDestroy lifecycle hook op = opts.op = 'beforeDestroy' return resolve(self[op](mapper, id, opts)).then(function () { op = opts.op = 'destroy' self.dbg(op, id, opts) // Destroy the record // TODO: Destroy related records when the &quot;with&quot; option is provided self.storage.removeItem(self.getIdPath(mapper, opts, id)) self.removeId(id, mapper, opts) // afterDestroy lifecycle hook op = opts.op = 'afterDestroy' return self[op](mapper, id, opts).then(function (_id) { // Allow for re-assignment from lifecycle hook id = isUndefined(_id) ? id : _id return opts.raw ? { data: id, deleted: 1 } : id }) }).then(success, failure) }) }) }, /** * Destroy the records that match the selection `query`. * * @name LocalStorageAdapter#destroyAll * @method * @param {Object} mapper The mapper. * @param {Object} query Selection query. * @param {Object} [opts] Configuration opts. * @param {boolean} [opts.raw=false] TODO * @return {Promise} */ destroyAll (mapper, query, opts) { const self = this query || (query = {}) opts || (opts = {}) return createTask(function (success, failure) { queueTask(function () { let op // beforeDestroyAll lifecycle hook op = opts.op = 'beforeDestroyAll' return resolve(self[op](mapper, query, opts)).then(function () { op = opts.op = 'destroyAll' self.dbg(op, query, opts) // Find the records that are to be destroyed return self.findAll(mapper, query, opts) }).then(function (records) { const idAttribute = mapper.idAttribute // Gather IDs of records to be destroyed let ids = records.map(function (record) { return get(record, idAttribute) }) // Destroy each record // TODO: Destroy related records when the &quot;with&quot; option is provided ids.forEach(function (id) { self.storage.removeItem(self.getIdPath(mapper, opts, id)) }) self.removeId(ids, mapper, opts) // afterDestroyAll lifecycle hook op = opts.op = 'afterDestroyAll' return self[op](mapper, query, opts, ids).then(function (_ids) { // Allow for re-assignment from lifecycle hook ids = isUndefined(_ids) ? ids : _ids return opts.raw ? { data: ids, deleted: records.length } : ids }) }).then(success, failure) }) }) }, /** * TODO * * @name LocalStorageAdapter#ensureId * @method */ ensureId (id, mapper, opts) { const ids = this.getIds(mapper, opts) if (isArray(id)) { if (!id.length) { return } id.forEach(function (_id) { ids[_id] = 1 }) } else { ids[id] = 1 } this.saveKeys(ids, mapper, opts) }, /** * Retrieve the record with the given primary key. * * @name LocalStorageAdapter#find * @method * @param {Object} mapper The mapper. * @param {(string|number)} id Primary key of the record to retrieve. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] TODO * @param {string[]} [opts.with=[]] TODO * @return {Promise} */ find (mapper, id, opts) { const self = this let record, op opts || (opts = {}) opts.with || (opts.with = []) // beforeFind lifecycle hook op = opts.op = 'beforeFind' return resolve(self[op](mapper, id, opts)).then(function () { op = opts.op = 'find' self.dbg(op, id, opts) const key = self.getIdPath(mapper, opts, id) record = self.storage.getItem(key) if (isUndefined(record)) { record = undefined return } record = fromJson(record) const tasks = [] forEachRelation(mapper, opts, function (def, __opts) { const relatedMapper = def.getRelation() let task if ((def.type === 'hasOne' || def.type === 'hasMany') &amp;&amp; def.foreignKey) { task = self.findAll(relatedMapper, { [def.foreignKey]: get(record, mapper.idAttribute) }, __opts).then(function (relatedItems) { if (def.type === 'hasOne' &amp;&amp; relatedItems.length) { set(record, def.localField, relatedItems[0]) } else { set(record, def.localField, relatedItems) } return relatedItems }) } else if (def.type === 'hasMany' &amp;&amp; def.localKeys) { let localKeys = [] let itemKeys = get(record, def.localKeys) || [] itemKeys = Array.isArray(itemKeys) ? itemKeys : Object.keys(itemKeys) localKeys = localKeys.concat(itemKeys || []) task = self.findAll(relatedMapper, { where: { [relatedMapper.idAttribute]: { 'in': unique(localKeys).filter(function (x) { return x }) } } }, __opts).then(function (relatedItems) { set(record, def.localField, relatedItems) return relatedItems }) } else if (def.type === 'belongsTo') { task = self.find(relatedMapper, get(record, def.foreignKey), __opts).then(function (relatedItem) { set(record, def.localField, relatedItem) return relatedItem }) } if (task) { tasks.push(task) } }) return Promise.all(tasks) }).then(function () { // afterFind lifecycle hook op = opts.op = 'afterFind' return resolve(self[op](mapper, id, opts, record)).then(function (_record) { // Allow for re-assignment from lifecycle hook record = isUndefined(_record) ? record : _record return opts.raw ? { data: record, found: record ? 1 : 0 } : record }) }) }, /** * Retrieve the records that match the selection `query`. * * @name LocalStorageAdapter#findAll * @method * @param {Object} mapper The mapper. * @param {Object} query Selection query. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] TODO * @param {string[]} [opts.with=[]] TODO * @return {Promise} */ findAll (mapper, query, opts) { const self = this let records = [] let op opts || (opts = {}) opts.with || (opts.with = []) // beforeFindAll lifecycle hook op = opts.op = 'beforeFindAll' return resolve(self[op](mapper, query, opts)).then(function () { op = opts.op = 'findAll' self.dbg(op, query, opts) // Load all records into memory... const ids = self.getIds(mapper, opts) forOwn(ids, function (value, id) { const json = self.storage.getItem(self.getIdPath(mapper, opts, id)) if (json) { records.push(fromJson(json)) } }) const idAttribute = mapper.idAttribute // TODO: Verify that this collection gets properly garbage collected // TODO: Or, find a way to filter without using Collection const _query = new Query({ index: { getAll () { return records } } }) records = _query.filter(query).run() const tasks = [] forEachRelation(mapper, opts, function (def, __opts) { const relatedMapper = def.getRelation() let task if ((def.type === 'hasOne' || def.type === 'hasMany') &amp;&amp; def.foreignKey) { task = self.findAll(relatedMapper, { where: { [def.foreignKey]: { 'in': records.map(function (item) { return get(item, idAttribute) }).filter(function (x) { return x }) } } }, __opts).then(function (relatedItems) { records.forEach(function (item) { const attached = [] relatedItems.forEach(function (relatedItem) { if (get(relatedItem, def.foreignKey) === get(item, idAttribute)) { attached.push(relatedItem) } }) if (def.type === 'hasOne' &amp;&amp; attached.length) { set(item, def.localField, attached[0]) } else { set(item, def.localField, attached) } }) return relatedItems }) } else if (def.type === 'hasMany' &amp;&amp; def.localKeys) { let localKeys = [] records.forEach(function (item) { let itemKeys = get(item, def.localKeys) || [] itemKeys = Array.isArray(itemKeys) ? itemKeys : Object.keys(itemKeys) localKeys = localKeys.concat(itemKeys || []) }) task = self.findAll(relatedMapper, { where: { [relatedMapper.idAttribute]: { 'in': unique(localKeys).filter(function (x) { return x }) } } }, __opts).then(function (relatedItems) { records.forEach(function (item) { const attached = [] let itemKeys = get(item, def.localKeys) || [] itemKeys = Array.isArray(itemKeys) ? itemKeys : Object.keys(itemKeys) relatedItems.forEach(function (relatedItem) { if (itemKeys &amp;&amp; itemKeys.indexOf(relatedItem[relatedMapper.idAttribute]) !== -1) { attached.push(relatedItem) } }) set(item, def.localField, attached) }) return relatedItems }) } else if (def.type === 'belongsTo') { task = self.findAll(relatedMapper, { where: { [relatedMapper.idAttribute]: { 'in': records.map(function (item) { return get(item, def.foreignKey) }).filter(function (x) { return x }) } } }, __opts).then(function (relatedItems) { records.forEach(function (item) { relatedItems.forEach(function (relatedItem) { if (relatedItem[relatedMapper.idAttribute] === get(item, def.foreignKey)) { set(item, def.localField, relatedItem) } }) }) return relatedItems }) } if (task) { tasks.push(task) } }) return Promise.all(tasks) }).then(function () { // afterFindAll lifecycle hook op = opts.op = 'afterFindAll' return resolve(self[op](mapper, query, opts, records)).then(function (_records) { // Allow for re-assignment from lifecycle hook records = isUndefined(_records) ? records : _records return opts.raw ? { data: records, found: records.length } : records }) }) }, /** * TODO * * @name LocalStorageAdapter#getPath * @method */ getPath (mapper, opts) { opts = opts || {} return makePath(opts.basePath === undefined ? (mapper.basePath === undefined ? this.basePath : mapper.basePath) : opts.basePath, mapper.name) }, /** * TODO * * @name LocalStorageAdapter#getIdPath * @method */ getIdPath (mapper, opts, id) { opts = opts || {} return makePath(opts.basePath || this.basePath || mapper.basePath, mapper.endpoint, id) }, /** * TODO * * @name LocalStorageAdapter#getIds * @method */ getIds (mapper, opts) { let ids const idsPath = this.getPath(mapper, opts) const idsJson = this.storage.getItem(idsPath) if (idsJson) { ids = fromJson(idsJson) } else { ids = {} } return ids }, /** * TODO * * @name LocalStorageAdapter#log * @method */ log (level, ...args) { if (level &amp;&amp; !args.length) { args.push(level) level = 'debug' } if (level === 'debug' &amp;&amp; !this.debug) { return } const prefix = `${level.toUpperCase()}: (LocalStorageAdapter)` if (console[level]) { console[level](prefix, ...args) } else { console.log(prefix, ...args) } }, /** * TODO * * @name LocalStorageAdapter#removeId * @method */ removeId (id, mapper, opts) { const ids = this.getIds(mapper, opts) if (isArray(id)) { if (!id.length) { return } id.forEach(function (_id) { delete ids[_id] }) } else { delete ids[id] } this.saveKeys(ids, mapper, opts) }, /** * TODO * * @name LocalStorageAdapter#saveKeys * @method */ saveKeys (ids, mapper, opts) { ids = ids || {} const idsPath = this.getPath(mapper, opts) if (Object.keys(ids).length) { this.storage.setItem(idsPath, toJson(ids)) } else { this.storage.removeItem(idsPath) } }, /** * Update the records that match the selection `query`. If a record with the * specified primary key cannot be found then no update is performed and the * promise is resolved with `undefined`. * * @name LocalStorageAdapter#update * @method * @param {Object} mapper The mapper. * @param {(string|number)} id The primary key of the record to be updated. * @param {Object} props The update to apply to the record. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] TODO * @return {Promise} */ update (mapper, id, props, opts) { const self = this props || (props = {}) opts || (opts = {}) return createTask(function (success, failure) { queueTask(function () { let op // beforeUpdate lifecycle hook op = opts.op = 'beforeUpdate' return resolve(self[op](mapper, id, props, opts)).then(function (_props) { // Allow for re-assignment from lifecycle hook props = isUndefined(_props) ? props : _props const key = self.getIdPath(mapper, opts, id) let record = self.storage.getItem(key) record = record ? fromJson(record) : undefined let updated = 0 // Update the record // TODO: Update related records when the &quot;with&quot; option is provided if (record) { deepMixIn(record, props) self.storage.setItem(key, toJson(record)) updated++ } // afterUpdate lifecycle hook op = opts.op = 'afterUpdate' return self[op](mapper, id, props, opts, record).then(function (_record) { // Allow for re-assignment from lifecycle hook record = isUndefined(_record) ? record : _record return opts.raw ? { data: record, updated } : record }) }).then(success, failure) }) }) }, /** * Update the records that match the selection `query`. * * @name LocalStorageAdapter#updateAll * @method * @param {Object} mapper The mapper. * @param {Object} props The update to apply to the selected records. * @param {Object} query Selection query. * @param {Object} [opts] Configuration options. * @return {Promise} */ updateAll (mapper, props, query, opts) { const self = this props || (props = {}) query || (query = {}) opts || (opts = {}) return createTask(function (success, failure) { queueTask(function () { let op // beforeUpdateAll lifecycle hook op = opts.op = 'beforeUpdateAll' return resolve(self[op](mapper, props, query, opts)).then(function (_props) { // Allow for re-assignment from lifecycle hook props = isUndefined(_props) ? props : _props op = opts.op = 'updateAll' self.dbg(op, query, opts) // Find the records that are to be updated return self.findAll(mapper, query, opts) }).then(function (records) { const idAttribute = mapper.idAttribute let updated = 0 // Update each record // TODO: Update related records when the &quot;with&quot; option is provided records.forEach(function (record) { record || (record = {}) const id = get(record, idAttribute) const key = self.getIdPath(mapper, opts, id) deepMixIn(record, props) self.storage.setItem(key, toJson(record)) updated++ }) // afterUpdateAll lifecycle hook op = opts.op = 'afterUpdateAll' return self[op](mapper, props, query, opts, records).then(function (_records) { // Allow for re-assignment from lifecycle hook records = isUndefined(_records) ? records : _records return opts.raw ? { data: records, updated } : records }) }).then(success, failure) }) }) }, /** * Update the given records in a single batch. * * @name LocalStorageAdapter#updateMany * @method * @param {Object} mapper The mapper. * @param {Object} records The records to update. * @param {Object} [opts] Configuration options. * @param {boolean} [opts.raw=false] TODO * @return {Promise} */ updateMany (mapper, records, opts) { const self = this records || (records = []) opts || (opts = {}) return createTask(function (success, failure) { queueTask(function () { let op let updatedRecords = [] // beforeUpdateMany lifecycle hook op = opts.op = 'beforeUpdateMany' return resolve(self[op](mapper, records, opts)).then(function (_records) { // Allow for re-assignment from lifecycle hook records = isUndefined(_records) ? records : _records op = opts.op = 'updateMany' self.dbg(op, records, opts) const idAttribute = mapper.idAttribute // Update each record // TODO: Update related records when the &quot;with&quot; option is provided records.forEach(function (record) { if (!record) { return } const id = get(record, idAttribute) if (isUndefined(id)) { return } const key = self.getIdPath(mapper, opts, id) let json = self.storage.getItem(key) const existingRecord = json ? fromJson(json) : undefined if (!existingRecord) { return } deepMixIn(existingRecord, record) self.storage.setItem(key, toJson(existingRecord)) updatedRecords.push(existingRecord) }) // afterUpdateMany lifecycle hook op = opts.op = 'afterUpdateMany' return self[op](mapper, records, opts, updatedRecords).then(function (_records) { // Allow for re-assignment from lifecycle hook records = isUndefined(_records) ? updatedRecords : _records return opts.raw ? { data: records, updated: updatedRecords.length } : records }) }).then(success, failure) }) }) } }) /** * Details of the current version of the `js-data-localstorage` module. * * @name LocalStorageAdapter.version * @type {Object} * @property {string} version.full The full semver value. * @property {number} version.major The major version number. * @property {number} version.minor The minor version number. * @property {number} version.patch The patch version number. * @property {(string|boolean)} version.alpha The alpha version value, * otherwise `false` if the current version is not alpha. * @property {(string|boolean)} version.beta The beta version value, * otherwise `false` if the current version is not beta. */ LocalStorageAdapter.version = { full: '&lt;%= pkg.version %&gt;', major: parseInt('&lt;%= major %&gt;', 10), minor: parseInt('&lt;%= minor %&gt;', 10), patch: parseInt('&lt;%= patch %&gt;', 10), alpha: '&lt;%= alpha %&gt;' !== 'false' ? '&lt;%= alpha %&gt;' : false, beta: '&lt;%= beta %&gt;' !== 'false' ? '&lt;%= beta %&gt;' : false } /** * Registered as `js-data-localstorage` in NPM and Bower. * * __Script tag__: * ```javascript * window.LocalStorageAdapter * ``` * __CommonJS__: * ```javascript * var LocalStorageAdapter = require('js-data-localstorage') * ``` * __ES6 Modules__: * ```javascript * import LocalStorageAdapter from 'js-data-localstorage' * ``` * __AMD__: * ```javascript * define('myApp', ['js-data-localstorage'], function (LocalStorageAdapter) { ... }) * ``` * * @module js-data-localstorage */ module.exports = LocalStorageAdapter × Search results Close Back to js-data.io "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" js-data-localstorage Modules js-data-localstorage Classes LocalStorageAdapter Modules Classes LocalStorageAdapter × Search results Close Back to js-data.io "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" js-data-localstorage Modules js-data-localstorage Classes LocalStorageAdapter Classes Classes LocalStorageAdapter × Search results Close Back to js-data.io "},"index.html":{"id":"index.html","title":"Index","body":" js-data-localstorage Modules js-data-localstorage Classes LocalStorageAdapter js-data-localstorage 3.0.0-alpha.2 js-data-localstorage localStorage adapter for js-data. Tested on IE9, Chrome 46, Firefox 41 &amp; Safari 7.1 using Table of contents Quick start Documentation API Reference Demo Support Community Contributing License Quick Startnpm install --save js-data js-data-localstorage or bower install --save js-data js-data-localstorage. Load js-data-localstorage.js after js-data.js. var adapter = new LocalStorageAdapter(); var store = new JSData.DataStore(); store.registerAdapter('localstorage', adapter, { default: true }); // &quot;store&quot; will now use the localstorage adapterYou can also provide a custom storage medium (it just needs to implement the localStorage API): var memory = {}; // Turn js-data-localstorage into an in-memory adapter var memoryAdapter = new LocalStorageAdapter({ storage: { getItem: function (key) { return memory[key]; }, setItem: function (key, value) { return memory[key] = value; }, removeItem: function (key) { delete memory[key]; } } }); // Turn js-data-localstorage into a sessionStorage adapter var sessionAdapter = new LocalStorageAdapter({ storage: sessionStorage });Documentation Getting Started with js-data js-data-http CHANGELOG.md API Reference js-data js-data-localstorage Demohttps://js-data-localstorage.firebaseapp.com/ SupportSupport questions are handled via StackOverflow, [Slack][slack], and the [Mailing List][ml]. Ask your questions there. Community StackOverflow Channel [Slack Chat][slack] [][slack] Announcements Mailing List Issues Tracker GitHub Contributing Guide ContributingWhen submitting bug reports or feature requests on GitHub, please include as much detail as possible. good - Your versions of Angular, JSData, etc, relevant console logs, stack traces, code examples that revealed the issue, etc. better - A plnkr, fiddle, or bin that demonstrates the issue best - A Pull Request that fixes the issue, including test coverage for the issue and the fix Pull Requests Contribute to the issue/discussion that is the reason you'll be developing in the first place Fork js-data git clone git@github.com:&lt;you&gt;/js-data-localstorage.git cd js-data-localstorage; npm install; Write your code, including relevant documentation and tests Run npm test (build and test) Your code will be linted and checked for formatting, the tests will be run The dist/ folder &amp; files will be generated, do NOT commit dist/*! They will be committed when a release is cut. Submit your PR and we'll review! Thanks! LicenseThe MIT License (MIT) Copyright (c) 2014-2016 Jason Dobry Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. × Search results Close Back to js-data.io "},"LocalStorageAdapter.html":{"id":"LocalStorageAdapter.html","title":"Class: LocalStorageAdapter","body":" js-data-localstorage Modules js-data-localstorage Classes LocalStorageAdapter Class: LocalStorageAdapter LocalStorageAdapter new LocalStorageAdapter(opts) LocalStorageAdapter class. Parameters: Name Type Argument Description opts Object &lt;optional&gt; Configuration opts. Properties Name Type Argument Default Description basePath string &lt;optional&gt; '' TODO debug boolean &lt;optional&gt; false TODO storeage Object &lt;optional&gt; localStorage TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 129 Example import {DataStore} from 'js-data' import LocalStorageAdapter from 'js-data-localstorage' const store = new DataStore() const adapter = new LocalStorageAdapter() store.registerAdapter('ls', adapter, { 'default': true }) Members &lt;static&gt; version :Object Details of the current version of the js-data-localstorage module. Type: Object Properties: Name Type Description version.full string The full semver value. version.major number The major version number. version.minor number The minor version number. version.patch number The patch version number. version.alpha string | boolean The alpha version value, otherwise false if the current version is not alpha. version.beta string | boolean The beta version value, otherwise false if the current version is not beta. Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 1045 basePath :string TODO Type: string Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 102 debug :boolean TODO Type: boolean Default Value: false Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 110 storage :Object TODO Type: Object Default Value: localStorage Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 119 Methods &lt;static&gt; extend(instanceProps, classProps) Alternative to ES6 class syntax for extending LocalStorageAdapter. Parameters: Name Type Argument Description instanceProps Object &lt;optional&gt; Properties that will be added to the prototype of the subclass. classProps Object &lt;optional&gt; Properties that will be added as static properties to the subclass itself. Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 150 Returns: Subclass of LocalStorageAdapter. Type Object afterCreate() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 164 afterCreateMany() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 170 afterDEL() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 176 afterDestroy() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 182 afterDestroyAll() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 188 afterFind() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 194 afterFindAll() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 200 afterGET() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 206 afterPUT() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 212 afterUpdate() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 218 afterUpdateAll() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 224 afterUpdateMany() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 230 beforeCreate() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 236 beforeCreateMany() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 242 beforeDEL() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 248 beforeDestroy() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 254 beforeDestroyAll() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 260 beforeFind() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 266 beforeFindAll() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 272 beforeGET() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 278 beforePUT() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 284 beforeUpdate() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 290 beforeUpdateAll() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 296 beforeUpdateMany() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 302 create(mapper, props, opts) Create a new record. Parameters: Name Type Argument Description mapper Object The mapper. props Object The record to be created. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 308 Returns: Type Promise createMany(mapper, props, opts) Create multiple records in a single batch. Parameters: Name Type Argument Description mapper Object The mapper. props Array Array of records to be created. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 356 Returns: Type Promise dbg() Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 407 destroy(mapper, id, opts) Destroy the record with the given primary key. Parameters: Name Type Argument Description mapper Object The mapper. id string | number Primary key of the record to destroy. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 415 Returns: Type Promise destroyAll(mapper, query, opts) Destroy the records that match the selection query. Parameters: Name Type Argument Description mapper Object The mapper. query Object Selection query. opts Object &lt;optional&gt; Configuration opts. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 458 Returns: Type Promise ensureId() TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 512 find(mapper, id, opts) Retrieve the record with the given primary key. Parameters: Name Type Argument Description mapper Object The mapper. id string | number Primary key of the record to retrieve. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false TODO with Array.&lt;string&gt; &lt;optional&gt; [] TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 533 Returns: Type Promise findAll(mapper, query, opts) Retrieve the records that match the selection query. Parameters: Name Type Argument Description mapper Object The mapper. query Object Selection query. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false TODO with Array.&lt;string&gt; &lt;optional&gt; [] TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 622 Returns: Type Promise getIdPath() TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 775 getIds() TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 786 getPath() TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 764 log() TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 804 removeId() TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 826 saveKeys() TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 847 update(mapper, id, props, opts) Update the records that match the selection query. If a record with the specified primary key cannot be found then no update is performed and the promise is resolved with undefined. Parameters: Name Type Argument Description mapper Object The mapper. id string | number The primary key of the record to be updated. props Object The update to apply to the record. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 863 Returns: Type Promise updateAll(mapper, props, query, opts) Update the records that match the selection query. Parameters: Name Type Argument Description mapper Object The mapper. props Object The update to apply to the selected records. query Object Selection query. opts Object &lt;optional&gt; Configuration options. Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 918 Returns: Type Promise updateMany(mapper, records, opts) Update the given records in a single batch. Parameters: Name Type Argument Description mapper Object The mapper. records Object The records to update. opts Object &lt;optional&gt; Configuration options. Properties Name Type Argument Default Description raw boolean &lt;optional&gt; false TODO Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 978 Returns: Type Promise × Search results Close Back to js-data.io "},"module-js-data-localstorage.html":{"id":"module-js-data-localstorage.html","title":"Module: js-data-localstorage","body":" js-data-localstorage Modules js-data-localstorage Classes LocalStorageAdapter Module: js-data-localstorage Registered as js-data-localstorage in NPM and Bower. Script tag: window.LocalStorageAdapterCommonJS: var LocalStorageAdapter = require('js-data-localstorage')ES6 Modules: import LocalStorageAdapter from 'js-data-localstorage'AMD: define('myApp', ['js-data-localstorage'], function (LocalStorageAdapter) { ... }) Source: /Users/jdobry/projects/js-data-localstorage/src/index.js, line 1068 × Search results Close Back to js-data.io "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
